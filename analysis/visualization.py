import os
import string
from typing import final
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px

'''
Python Class that takes in the fill, order, and pnl files generated by Strategy Studio Backtesting software and then have different visualiaztion functions
'''
class StrategyAnalysis:
    # @param fill_file: fill file generated by Strategy Studio Backtesting
    # @param order_file: Order file generated by Strategy Studio Backtesting
    # @param pnl_file: PnL file generated by Strategy Studio Backtesting
    def __init__(self, fill_file, order_file, pnl_file, initial_value=10000000):
        # Filepath check
        self.checkPath(fill_file)
        self.checkPath(order_file)
        self.checkPath(pnl_file)
        # read these files into Dataframe
        try:
            fill = pd.read_csv(fill_file)
            cols = ["StrategyName", "TradeTime", "Price", "Quantity", "ExecutionCost"]
            assert all(col in fill.columns for col in cols)
            self.fill = fill[cols]
        except:
            raise Exception('Invalid fill file %s' %(fill_file))
        try:
            order = pd.read_csv(order_file)
            cols = ["StrategyName", "LastModTime", "State", "Symbol", "Price", "Quantity", "DisplayQuantity", "FilledQty", "Remains", "AvgFillPrice", "ExecutionCost", "MarketCenter"]
            assert all(col in order.columns for col in cols)
            self.order = order[cols]
        except:
            raise Exception('Invalid order file %s' %(order_file))
        try:
            self.pnl = pd.read_csv(pnl_file)
        except:
            raise Exception('Invalid pnl file %s' %(pnl_file))


        self.name = None
        if len(self.fill) > 0:
            self.name = self.fill["StrategyName"][0]

        self.beginTime = self.fill['TradeTime'][0]
        self.endTime = self.fill['TradeTime'][len(self.fill) - 1]
        self.initial_value = initial_value
        

    def measureStrategy(self, print_value = False):
        net_pnl = self.pnl["Cumulative PnL"].to_numpy()
        time_pnl = self.pnl["Time"].to_numpy()
        net_pnl_percent = net_pnl / self.initial_value

        cumulative_returns = net_pnl_percent[-1]
        pnl_std = net_pnl_percent.std()

        # Sharpe Ratio, final net return / standard deviation
        sharpe_ratio = cumulative_returns / pnl_std

        # Maximum Drowndown
        max_pnl = np.max(net_pnl)
        min_pnl = np.min(net_pnl)
        max_drowndown = (min_pnl - max_pnl) / (self.initial_value + max_pnl)

        # Begin and End investment value
        initial_value = self.initial_value
        final_val = self.initial_value + net_pnl[-1]
        
        if print_value:
            print("Initial Investment Value: ", initial_value)
            print("Final Investment Value: ", final_val)
            print("Begin at: ", time_pnl[0])
            print("End at: ", time_pnl[-1])
            print("Final return: ", net_pnl[-1])
            print("Maximum PnL: ", max_pnl)
            print("Minimum PnL", min_pnl)
            print("Cumulative Returns: " + f"{cumulative_returns:.4%}")
            print("Sharpe Ratio: ", sharpe_ratio)
            print("Maximum Drowndown: " + f"{max_drowndown:.4%}")

        return [initial_value, final_val, time_pnl[0], time_pnl[-1], net_pnl[-1], max_pnl, min_pnl, cumulative_returns, sharpe_ratio, max_drowndown]

            
    # Visualizat different metric standard by passing in the metrics
    # TODO Setup visualization for different evaluation standards
    # @param metric: types of metric the user would like to visualize, could either to be [], or simply one 
    '''
        metric: 'price'
    '''
    def visualization():
        print("Visualization")
    
    # Visualize PnL CSV file 
    def visualizePNL(self):
        pnl_ = self.pnl[['Time', 'Cumulative PnL']]
        time_pnl = pnl_.to_numpy()
        N = time_pnl.shape[0]
        date_data = time_pnl[:, 0]
        cumulative_pnl = time_pnl[:, 1]

        time_series_fig = px.line(pnl_, x=pnl_['Time'], y="Cumulative PnL")
        time_series_fig.show()

        date_label = [date_data[0].split(' ')[0]]
        pnl_by_date = []
        temp = [cumulative_pnl[0]]
        for i in range(1, N):
            date = date_data[i].split(' ')[0]
            if date == date_label[-1]:
                temp.append(float(cumulative_pnl[i]))
            else:
                date_label.append(date)
                pnl_by_date.append(np.array(temp))
                temp = [cumulative_pnl[i]]
        pnl_by_date.append(temp)
        pnl_by_date = pnl_by_date

        pnl_open = [arr[0] for arr in pnl_by_date]
        pnl_last = [arr[-1] for arr in pnl_by_date]
        pnl_high = [max(arr) for arr in pnl_by_date]
        pnl_low = [min(arr) for arr in pnl_by_date]

        bar_fig = go.Figure(data=[
            go.Candlestick(
                x=date_label,
                open=pnl_open,
                high=pnl_high,
                low=pnl_low,
                close=pnl_last)
        ])

        bar_fig.show()


    # Validate the file path
    # @param file_path: path of the file to check the existence
    def checkPath(self, file_path):
        if not os.path.exists(file_path):
            print("Invalid file path!")
            exit()
            
    # Get relevant data by type
    # @param types: types of the data to get, could be None for all, could be either fill, order, or pnl. Otherwise, it will return all
    def getData(self, types = None):
        if types == None:
            return [self.fill, self.order, self.pnl]
        types = types.lower()
        if types == "fill":
            return self.fill
        elif types == "order":
            return self.order
        elif types == "pnl":
            return self.pnl
        return [self.fill, self.order, self.pnl]
